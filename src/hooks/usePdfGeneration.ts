import { useState, useCallback, useRef } from 'react';\nimport { Template } from '@pdfme/common';\nimport { pdfmeService, PdfGenerationProgress } from '../services/PdfmeService';\nimport { TemplateType } from '../types/PdfTemplates';\n\nexport interface UsePdfGenerationOptions {\n  onSuccess?: (pdfData: Uint8Array, filename: string) => void;\n  onError?: (error: string) => void;\n  autoDownload?: boolean;\n}\n\nexport interface UsePdfGenerationResult {\n  // State\n  isGenerating: boolean;\n  progress: PdfGenerationProgress | null;\n  error: string | null;\n  lastGeneratedPdf: Uint8Array | null;\n  generationHistory: Array<{ filename: string; timestamp: Date; size: number }>;\n  \n  // Actions\n  generatePdf: (template: Template, inputs: Record<string, any>[], filename?: string) => Promise<void>;\n  downloadPdf: (pdfData?: Uint8Array, filename?: string) => Promise<void>;\n  previewPdf: (pdfData?: Uint8Array) => Promise<void>;\n  clearError: () => void;\n  clearHistory: () => void;\n  retryLastGeneration: () => Promise<void>;\n  \n  // Performance metrics\n  lastGenerationTime: number | null;\n  averageGenerationTime: number;\n}\n\nexport const usePdfGeneration = (options: UsePdfGenerationOptions = {}): UsePdfGenerationResult => {\n  const { onSuccess, onError, autoDownload = true } = options;\n  \n  // State\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [progress, setProgress] = useState<PdfGenerationProgress | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [lastGeneratedPdf, setLastGeneratedPdf] = useState<Uint8Array | null>(null);\n  const [generationHistory, setGenerationHistory] = useState<Array<{ filename: string; timestamp: Date; size: number }>>([]);\n  const [lastGenerationTime, setLastGenerationTime] = useState<number | null>(null);\n  \n  // Performance tracking\n  const generationTimes = useRef<number[]>([]);\n  const lastGenerationParams = useRef<{ template: Template; inputs: Record<string, any>[]; filename?: string } | null>(null);\n  \n  // Calculate average generation time\n  const averageGenerationTime = generationTimes.current.length > 0 \n    ? generationTimes.current.reduce((sum, time) => sum + time, 0) / generationTimes.current.length\n    : 0;\n\n  const generatePdf = useCallback(async (\n    template: Template, \n    inputs: Record<string, any>[], \n    filename?: string\n  ) => {\n    const startTime = Date.now();\n    setIsGenerating(true);\n    setError(null);\n    setProgress(null);\n    \n    // Store parameters for retry functionality\n    lastGenerationParams.current = { template, inputs, filename };\n    \n    try {\n      // Validate inputs before generation\n      if (!template) {\n        throw new Error('Template is required for PDF generation');\n      }\n      \n      if (!inputs || inputs.length === 0) {\n        throw new Error('Input data is required for PDF generation');\n      }\n      \n      const finalFilename = filename || `document-${Date.now()}.pdf`;\n      \n      // Performance monitoring\n      const performanceObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          if (entry.name === 'pdf-generation') {\n            console.log(`PDF Generation Performance: ${entry.duration}ms`);\n          }\n        });\n      });\n      \n      performanceObserver.observe({ entryTypes: ['measure'] });\n      performance.mark('pdf-generation-start');\n      \n      // Generate PDF with progress tracking\n      const pdfData = await pdfmeService.generatePdf(template, inputs, {\n        filename: finalFilename,\n        onProgress: (progressData) => {\n          setProgress(progressData);\n        }\n      });\n      \n      performance.mark('pdf-generation-end');\n      performance.measure('pdf-generation', 'pdf-generation-start', 'pdf-generation-end');\n      \n      const endTime = Date.now();\n      const generationTime = endTime - startTime;\n      \n      // Update performance metrics\n      setLastGenerationTime(generationTime);\n      generationTimes.current.push(generationTime);\n      \n      // Keep only last 10 generation times for average calculation\n      if (generationTimes.current.length > 10) {\n        generationTimes.current.shift();\n      }\n      \n      // Store generated PDF\n      setLastGeneratedPdf(pdfData);\n      \n      // Update generation history\n      setGenerationHistory(prev => [\n        {\n          filename: finalFilename,\n          timestamp: new Date(),\n          size: pdfData.length\n        },\n        ...prev.slice(0, 9) // Keep last 10 generations\n      ]);\n      \n      // Auto-download if enabled\n      if (autoDownload) {\n        await pdfmeService.downloadPdf(pdfData, finalFilename);\n      }\n      \n      // Call success callback\n      onSuccess?.(pdfData, finalFilename);\n      \n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred during PDF generation';\n      setError(errorMessage);\n      onError?.(errorMessage);\n    } finally {\n      setIsGenerating(false);\n      setProgress(null);\n    }\n  }, [onSuccess, onError, autoDownload]);\n  \n  const downloadPdf = useCallback(async (pdfData?: Uint8Array, filename?: string) => {\n    try {\n      const dataToDownload = pdfData || lastGeneratedPdf;\n      if (!dataToDownload) {\n        throw new Error('No PDF data available for download');\n      }\n      \n      const finalFilename = filename || `document-${Date.now()}.pdf`;\n      await pdfmeService.downloadPdf(dataToDownload, finalFilename);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to download PDF';\n      setError(errorMessage);\n      onError?.(errorMessage);\n    }\n  }, [lastGeneratedPdf, onError]);\n  \n  const previewPdf = useCallback(async (pdfData?: Uint8Array) => {\n    try {\n      const dataToPreview = pdfData || lastGeneratedPdf;\n      if (!dataToPreview) {\n        throw new Error('No PDF data available for preview');\n      }\n      \n      await pdfmeService.previewPdf(dataToPreview);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to preview PDF';\n      setError(errorMessage);\n      onError?.(errorMessage);\n    }\n  }, [lastGeneratedPdf, onError]);\n  \n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n  \n  const clearHistory = useCallback(() => {\n    setGenerationHistory([]);\n    generationTimes.current = [];\n    setLastGenerationTime(null);\n  }, []);\n  \n  const retryLastGeneration = useCallback(async () => {\n    if (!lastGenerationParams.current) {\n      setError('No previous generation to retry');\n      return;\n    }\n    \n    const { template, inputs, filename } = lastGenerationParams.current;\n    await generatePdf(template, inputs, filename);\n  }, [generatePdf]);\n  \n  return {\n    // State\n    isGenerating,\n    progress,\n    error,\n    lastGeneratedPdf,\n    generationHistory,\n    \n    // Actions\n    generatePdf,\n    downloadPdf,\n    previewPdf,\n    clearError,\n    clearHistory,\n    retryLastGeneration,\n    \n    // Performance metrics\n    lastGenerationTime,\n    averageGenerationTime\n  };\n};