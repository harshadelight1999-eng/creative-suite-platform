import { Template, SchemaForUI } from '@pdfme/common';\n\n/**\n * PDF utility functions for optimization and validation\n */\n\nexport interface PdfOptimizationOptions {\n  compressImages?: boolean;\n  maxImageWidth?: number;\n  maxImageHeight?: number;\n  imageQuality?: number; // 0.1 to 1.0\n  removeUnusedFonts?: boolean;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\n/**\n * Validate PDF template structure and content\n */\nexport const validateTemplate = (template: Template): ValidationResult => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n  \n  try {\n    // Check if template exists\n    if (!template) {\n      errors.push('Template is required');\n      return { isValid: false, errors, warnings };\n    }\n    \n    // Check schemas\n    if (!template.schemas || template.schemas.length === 0) {\n      errors.push('Template must have at least one schema');\n    }\n    \n    // Validate each schema\n    template.schemas.forEach((schema, schemaIndex) => {\n      if (!schema || typeof schema !== 'object') {\n        errors.push(`Schema ${schemaIndex} is invalid`);\n        return;\n      }\n      \n      const fieldCount = Object.keys(schema).length;\n      if (fieldCount === 0) {\n        warnings.push(`Schema ${schemaIndex} has no fields`);\n      }\n      \n      // Validate each field in the schema\n      Object.entries(schema).forEach(([fieldName, field]) => {\n        if (!field || typeof field !== 'object') {\n          errors.push(`Field '${fieldName}' in schema ${schemaIndex} is invalid`);\n          return;\n        }\n        \n        // Check required properties\n        if (!field.type) {\n          errors.push(`Field '${fieldName}' is missing type property`);\n        }\n        \n        if (!field.position) {\n          errors.push(`Field '${fieldName}' is missing position property`);\n        } else {\n          if (typeof field.position.x !== 'number' || typeof field.position.y !== 'number') {\n            errors.push(`Field '${fieldName}' has invalid position coordinates`);\n          }\n          \n          // Check for reasonable position values\n          if (field.position.x < 0 || field.position.y < 0) {\n            warnings.push(`Field '${fieldName}' has negative position coordinates`);\n          }\n          \n          if (field.position.x > 600 || field.position.y > 800) {\n            warnings.push(`Field '${fieldName}' may be positioned outside typical page bounds`);\n          }\n        }\n        \n        if (typeof field.width !== 'number' || typeof field.height !== 'number') {\n          errors.push(`Field '${fieldName}' has invalid width or height`);\n        }\n        \n        // Type-specific validations\n        if (field.type === 'text') {\n          if (field.fontSize && (field.fontSize < 6 || field.fontSize > 72)) {\n            warnings.push(`Field '${fieldName}' has unusual font size: ${field.fontSize}pt`);\n          }\n        }\n        \n        if (field.type === 'image') {\n          if (field.width && field.height) {\n            const aspectRatio = field.width / field.height;\n            if (aspectRatio > 10 || aspectRatio < 0.1) {\n              warnings.push(`Field '${fieldName}' has extreme aspect ratio`);\n            }\n          }\n        }\n      });\n    });\n    \n  } catch (error) {\n    errors.push(`Template validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings\n  };\n};\n\n/**\n * Validate input data against template schema\n */\nexport const validateInputData = (\n  inputs: Record<string, any>[], \n  template: Template\n): ValidationResult => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n  \n  try {\n    if (!inputs || inputs.length === 0) {\n      errors.push('Input data is required');\n      return { isValid: false, errors, warnings };\n    }\n    \n    if (!template || !template.schemas) {\n      errors.push('Valid template is required for input validation');\n      return { isValid: false, errors, warnings };\n    }\n    \n    // Check if number of inputs matches number of schemas (pages)\n    if (inputs.length !== template.schemas.length) {\n      warnings.push(\n        `Number of input records (${inputs.length}) does not match number of template schemas (${template.schemas.length})`\n      );\n    }\n    \n    // Validate each input record\n    inputs.forEach((input, inputIndex) => {\n      if (!input || typeof input !== 'object') {\n        errors.push(`Input record ${inputIndex} is invalid`);\n        return;\n      }\n      \n      const schemaIndex = Math.min(inputIndex, template.schemas.length - 1);\n      const schema = template.schemas[schemaIndex];\n      \n      if (!schema) {\n        errors.push(`No schema available for input record ${inputIndex}`);\n        return;\n      }\n      \n      // Check for required fields\n      const schemaFields = Object.keys(schema);\n      const inputFields = Object.keys(input);\n      \n      const missingFields = schemaFields.filter(field => !(field in input));\n      const extraFields = inputFields.filter(field => !(field in schema));\n      \n      if (missingFields.length > 0) {\n        warnings.push(`Input record ${inputIndex} is missing fields: ${missingFields.join(', ')}`);\n      }\n      \n      if (extraFields.length > 0) {\n        warnings.push(`Input record ${inputIndex} has extra fields: ${extraFields.join(', ')}`);\n      }\n      \n      // Validate field data types\n      inputFields.forEach(fieldName => {\n        const fieldValue = input[fieldName];\n        const fieldSchema = schema[fieldName];\n        \n        if (fieldSchema) {\n          if (fieldSchema.type === 'text' && typeof fieldValue !== 'string') {\n            warnings.push(`Field '${fieldName}' in input ${inputIndex} should be a string`);\n          }\n          \n          if (fieldSchema.type === 'image' && fieldValue) {\n            // Basic image data validation\n            if (typeof fieldValue === 'string') {\n              if (!fieldValue.startsWith('data:image/') && !fieldValue.startsWith('http')) {\n                warnings.push(`Field '${fieldName}' in input ${inputIndex} may not be a valid image URL or data URL`);\n              }\n            }\n          }\n        }\n      });\n    });\n    \n  } catch (error) {\n    errors.push(`Input validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings\n  };\n};\n\n/**\n * Optimize template for better performance\n */\nexport const optimizeTemplate = (\n  template: Template, \n  options: PdfOptimizationOptions = {}\n): Template => {\n  const {\n    maxImageWidth = 1200,\n    maxImageHeight = 1200,\n    removeUnusedFonts = true\n  } = options;\n  \n  try {\n    const optimizedTemplate = JSON.parse(JSON.stringify(template)); // Deep clone\n    \n    optimizedTemplate.schemas = optimizedTemplate.schemas.map((schema) => {\n      const optimizedSchema: Record<string, any> = {};\n      \n      Object.entries(schema).forEach(([fieldName, field]) => {\n        const optimizedField = { ...field };\n        \n        // Optimize image fields\n        if (field.type === 'image') {\n          // Constrain image dimensions\n          if (field.width > maxImageWidth) {\n            const ratio = maxImageWidth / field.width;\n            optimizedField.width = maxImageWidth;\n            optimizedField.height = field.height * ratio;\n          }\n          \n          if (optimizedField.height > maxImageHeight) {\n            const ratio = maxImageHeight / optimizedField.height;\n            optimizedField.height = maxImageHeight;\n            optimizedField.width = optimizedField.width * ratio;\n          }\n        }\n        \n        // Optimize text fields\n        if (field.type === 'text') {\n          // Ensure reasonable font sizes\n          if (field.fontSize && field.fontSize > 72) {\n            optimizedField.fontSize = 72;\n          }\n          \n          if (field.fontSize && field.fontSize < 6) {\n            optimizedField.fontSize = 6;\n          }\n          \n          // Remove unused font properties\n          if (removeUnusedFonts) {\n            if (!field.fontName || field.fontName === 'Helvetica') {\n              delete optimizedField.fontName; // Use default\n            }\n          }\n        }\n        \n        optimizedSchema[fieldName] = optimizedField;\n      });\n      \n      return optimizedSchema;\n    });\n    \n    return optimizedTemplate;\n  } catch (error) {\n    console.warn('Template optimization failed:', error);\n    return template; // Return original template if optimization fails\n  }\n};\n\n/**\n * Calculate estimated PDF file size\n */\nexport const estimatePdfSize = (template: Template, inputs: Record<string, any>[]): number => {\n  try {\n    let estimatedSize = 10000; // Base PDF overhead (~10KB)\n    \n    template.schemas.forEach((schema, schemaIndex) => {\n      // Page overhead\n      estimatedSize += 2000; // ~2KB per page\n      \n      Object.entries(schema).forEach(([fieldName, field]) => {\n        const input = inputs[schemaIndex] || {};\n        const fieldValue = input[fieldName];\n        \n        if (field.type === 'text' && fieldValue) {\n          // Estimate text size: ~10 bytes per character\n          estimatedSize += String(fieldValue).length * 10;\n        }\n        \n        if (field.type === 'image' && fieldValue) {\n          // Estimate image size based on dimensions\n          const width = field.width || 100;\n          const height = field.height || 100;\n          const pixelCount = width * height;\n          \n          // Rough estimate: 1-3 bytes per pixel depending on compression\n          estimatedSize += pixelCount * 2;\n        }\n      });\n    });\n    \n    return Math.round(estimatedSize);\n  } catch (error) {\n    console.warn('PDF size estimation failed:', error);\n    return 50000; // Default estimate: 50KB\n  }\n};\n\n/**\n * Format file size for display\n */\nexport const formatFileSize = (bytes: number): string => {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n};\n\n/**\n * Generate a unique filename with timestamp\n */\nexport const generateUniqueFilename = (baseName: string = 'document', extension: string = 'pdf'): string => {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n  const cleanBaseName = baseName.replace(/[^a-zA-Z0-9-_]/g, '_');\n  return `${cleanBaseName}_${timestamp}.${extension}`;\n};\n\n/**\n * Check browser compatibility for PDF features\n */\nexport const checkBrowserCompatibility = (): {\n  isSupported: boolean;\n  features: Record<string, boolean>;\n  recommendations: string[];\n} => {\n  const features = {\n    webAssembly: typeof WebAssembly !== 'undefined',\n    arrayBuffer: typeof ArrayBuffer !== 'undefined',\n    uint8Array: typeof Uint8Array !== 'undefined',\n    blob: typeof Blob !== 'undefined',\n    url: typeof URL !== 'undefined',\n    download: 'download' in document.createElement('a'),\n    fileReader: typeof FileReader !== 'undefined',\n    canvas: !!document.createElement('canvas').getContext,\n    worker: typeof Worker !== 'undefined'\n  };\n  \n  const supportedFeatures = Object.values(features).filter(Boolean).length;\n  const totalFeatures = Object.keys(features).length;\n  const isSupported = supportedFeatures >= totalFeatures * 0.8; // 80% feature support\n  \n  const recommendations: string[] = [];\n  \n  if (!features.webAssembly) {\n    recommendations.push('WebAssembly is not supported. Consider using a modern browser.');\n  }\n  \n  if (!features.download) {\n    recommendations.push('File download may not work properly in this browser.');\n  }\n  \n  if (!features.worker) {\n    recommendations.push('Web Workers are not supported. PDF generation may be slower.');\n  }\n  \n  return {\n    isSupported,\n    features,\n    recommendations\n  };\n};\n\n/**\n * Performance monitoring utilities\n */\nexport const createPerformanceMonitor = () => {\n  const metrics: Record<string, number[]> = {};\n  \n  return {\n    startTimer: (operation: string) => {\n      performance.mark(`${operation}-start`);\n    },\n    \n    endTimer: (operation: string) => {\n      performance.mark(`${operation}-end`);\n      performance.measure(operation, `${operation}-start`, `${operation}-end`);\n      \n      const measure = performance.getEntriesByName(operation, 'measure')[0];\n      if (measure) {\n        if (!metrics[operation]) {\n          metrics[operation] = [];\n        }\n        metrics[operation].push(measure.duration);\n        \n        // Keep only last 20 measurements\n        if (metrics[operation].length > 20) {\n          metrics[operation].shift();\n        }\n      }\n    },\n    \n    getAverageTime: (operation: string): number => {\n      const times = metrics[operation];\n      if (!times || times.length === 0) return 0;\n      return times.reduce((sum, time) => sum + time, 0) / times.length;\n    },\n    \n    getMetrics: () => ({ ...metrics }),\n    \n    clearMetrics: () => {\n      Object.keys(metrics).forEach(key => {\n        metrics[key] = [];\n      });\n    }\n  };\n};